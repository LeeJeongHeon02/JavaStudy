--Object클래스--
클래스에 상속 받을 부모 클래스가 없으면 묵시적으로 Object클래스를 상속받는다.
자바에서 모든 객체의 최종 부모가 Object인 이유:
    공통 기능 제공, 다형성의 기본 구현이다.

--Object다형성--
Object는 모든 클래스의 부모 클래스이다. 따라서 Object는 모든 객체를 참조할 수 있다.
Object를 활용한 다형성의 한계:
    1. Object는 모든 객체를 대상으로 다형적 참조를 할 수 있다.
    2. Object를 통해 전달 받은 객체의 메서드를 호출하려면 각 객체에 맞는 다운캐스팅 과정이 필요하다.

--toString()--
Object.toString() 메서드는 객체의 정보를 문자열 형태로 제공한다.
위 메서드가 클래스 정보와 참조값으 제공하지만 이 정보만으로는 객체의 상태를 적절히 나타내지 못한다.
그래서 보통 toString()을 재정의(오버라이딩)해서 보다 유용한 정보를 제공한다.(generator 단축키를 통해 간단하게 생성가능)
String refValue = Integer.toHexString(System.identityHashCode(dog1));
System.out.println("refValue = " + refValue);
위 기능을 활용하면 객체의 참조값을 출력할 수 있다.

--Object와 OCP--
한 클래스가 구체적인 특정 클래스(Car, Dog등)를 사용하는 것을 ~에 의존한다고 표현한다.
부모 타입으로 올라갈수록 더 추상적이고, 하위 타입으로 내려갈수록 개념은 더 구체적이게 된다.
정적 의존관계는 컴파일 시간에 결정되며, 주로 클래스 간의 관계를 의미한다.
동적 의존관계는 프로그램을 실행하는 런타임에 확인할 수 있는 의존관계이다.
    예를들어서 ObjectPrinter.print(Object obj) 에 인자로 어떤 객체가 전달될지는 프로그램을 실행해야 알 수 있다.

--equals()--
1. 동일성과 동등성
    동일성(Identity): ==연산자를 사용해서 두 객체의 '참조'가 동일한 객체를 가리키고 있는지 확인
    동등성(Equality): equals()메서드를 사용하여 두 객체가 논리적으로 동등한지 확인
    하지만 Object가 기본으로 제공하는 equals()는 ==으로 동일성 비교를 제공한다.
    따라서 동등성 비교를 하고 싶으면 equals()메서드를 재정의해야한다.
2. 구현
    정확한 equals()를 구현하려면 generator에서 equals()를 선택하면 자동으로 만들어준다.
    equals()를 구현할 때 지켜야 하는 규칙들(반사성, 대칭성, 추이성, 일관성, null에 대한 비교)을 지켜서 만들어준다.

--불변 객체--
공유된 객체의 값을 변경해서 사이드 이팩트가 생기는것을 불변객체를 만듦으로써 막을 수 있다.
값을 변경할 수 없게 setValue 와 같은 메서드를 없애면 된다.
불변 객체의 값을 변경하고 싶으면, 기존 값에 새로운 값을 더해서 객체로 반환시켜주면 된다. (변수에 할당하는 과정 필수)
클래스를 불변의로 설계하는 이유 : 캐시 안정성, 멀티 쓰레드 안정성, 엔티티의 값 타입 등..
'참고' 불변 객체에서 값을 변경하는 경우 메서드명을 with~()로 지어주는 관례가 있다.
    예를 들어 coffee with sugar 라고 하면, 커피에 설탕이 추가되어서 원래의 상태를 변경하여 새로운 변형을 만든다는 것을 의미한다.

--String 클래스--
String클래스는 private final char[] value; 안에 실제 문자열의 값이 보관된다.
String은 원래 클래스이므로 +와 같은 연산이 아닌 "".concat() 과 같은 메서드를 사용해야하지만, 편의상 +연산이 가능하다.
String클래스 비교할 때는 == 비교가 아니라 항상 .equals() 비교(동등성 비교)를 해야 한다.
String str3 = "hello" 와 같이 문자열 리터럴을 사용하는 경우 자바는 메모리 효율성과 성능 최적화를 위해 문자열 풀을 사용한다.
    자바가 실행되는 시점에 클래스에 문자열 리터럴이 있으면 문자열 풀에 String인스턴스를 미리 만든다.(같은 문자열이 있으면 만들지 않음)
String클래스는 불변 객체이다. 따라서 생성 이후에 절대로 내부의 문자열 값을 변경할 수 없다.
String클래스는 다양한 메서드를 제공한다.
    문자열 정보 조회(길이, 비어있는지, 지정된 인덱스에 있는 문자 반환 등)
    문자열 비교(동일한지 비교, 사전 순으로 비교, 대소문자 구분 유무, 특정 접미사 접두사 등)
    문자열 검색(특정 문자열을 포함하고 있는지, 문자열이 처음 등장하는 위치, 마지막으로 등장하는 위치 등)
    문자열 조작 및 변환(문자열의 부분 문자열 반환, 공백 제거, 문자열 합치기, 특정 문자열을 새 문자열로 대체 등)
    문자열 분할 및 조합(문자열을 정규 표현식을 기준으로 분할, 주어진 구분자로 여러 문자열을 결합)
불변인 String클래스의 단점은 문자를 더하거나 변경할 때 마다 계속해서 새로운 객체를 생성해야 한다는 점이다.
    이를 해결하기 위해 StringBuilder라는 가변 String을 제공한다.
    StringBuilder는 내부에 final이 아닌 변경할 수 있는 byte[]를 가지고있다.
    append(), insert(), delete(), reverse()등을 이용해 문자열을 추가, 삽입, 삭제할수있다.
    StringBuilder는 보통 문자열을 변경하는 동안만 사용하다가 문자열 변경이 끝나면 안전한 불변String으로 변환하는것이 좋다.

--- String최적화 ---
문자열 리터럴 최적화
    컴파일 전 : String helloWorld = "Hello, " + "World!";
    컴파일 후 :  String helloWorld = "Hello, World!";
String변수 최적화 : 문자열 변수의 경우 그 안에 어떤 값이 들어있는지 컴파일 시점에는알 수 없기때문에 단순하게 합칠 수 없다.
            (최적화 방식은 자바 버전에 따라 달라지고, 자바9부터는 StringConcatFactory를 사용해서 최적화한다)
for문같은 루프안에서 문자열을 더하는 경우는 최적화가 이루어지지 않는다.
    왜냐하면 반복할때마다 StringBuilder객체를 생성하기 때문이다.
    이럴때는 직접 StringBuilder를 사용해서 반복문에서 append해주면 된다.
StringBuilder를 직접 사용하는 것이 더 좋은 경우
    반복문에서 반복해서 문자를 연결할 때
    조건문을 통해 동적으로 문자열을 조합할 때
    복잡한 문자열의 특정 부분을 변경해야할 때
    매우 긴 대용량 문자열을 다룰 때
(참고) 스트링빌더랑 같은 StringBuffer클래스도 있다. 멀티 스레드 상황에 안전하게 사용할 수 있지만 동기화 오버헤드로 인해 성능이 느리다.

--- 메서드 체인닝, Method Chaining ---
public class ValueAdder {
private int value;
public ValueAdder add(int addValue) {
        value += addValue;
    return this;
}} 이런식으로 return 값으로 자기 자신의 참조값을 반환시킬 수 있다.
ValueAdder adder = new ValueAdder();
     int result = adder.add(1).add(2).add(3).getValue();
그러면 위와 같은 방법으로 반환된 참조값을 즉시 메서드 호출에 사용할 수 있다.
이게 메서드 체이닝이다. 코드를 간결하고 읽기 쉽게 만들어준다.
StringBuilder도 이와같은 메서드 체이닝 기법을 제공한다.
    StringBuilder의 append()메서드를 보면 자기 자신의 참조값을 반환한다.
    다른 문자열을 변경하는 대부분의 메서드도 메서드 체이닝 기법을 제공하기 위해 자기 자신을 반환한다.
    "만드는 사람이 수고로우면 쓰는 사람이 편하고, 만드는 사람이 편하면 쓰는 사람이 수고롭다."

String 클래스의 indexOf()메서드는 찾는 값이 없으면 -1을 반환한다.
    indexOf(String str, int beginIndex, int endIndex) 형식으로 시작인덱스랑 종료인덱스를 설정할 수 있다.

String.join() 메서드는 static메서드이므로 특정 객체의 인스턴스 생성 없이 호출할 수 있다. 일반적으로 클래스 이름을 통해 호출한다.

--래퍼 클래스--
특정 기본형을 감싸서(Wrap)만드는 클래스를 래퍼 클래스 라고 한다.
자바가 제공하는 기본 래퍼 클래스는 1.불변이다. 2.equals로 비교해야 한다. 는 특징이 있다.
기본형을 래퍼 클래스로 변경하는 것을 마치 박스에 물건을 넣은 것 같다고 해서 박싱(Boxing)이라 한다.
    Integer.valueOf(10)을 사용해서 객체를 생성하면 된다.
    추가로 Integer.valueOf()에는 -128부터 127범위의 Integer클래스를 미리 캐싱해두고, 해당 범위의 값을 조회하면 미리 생성된 객체를 반환해준다.
래퍼 클래스에 들어있는 기본형 값을 다시 꺼내느 메서드 - intValue() : 언박싱
현재 자바에는 오토 박싱, 오토 언박싱 기능이 있다. Integer boxedValue = intvalue; 이런식
기본형, 래퍼 클래스 중에서 연산 속도는 기본형이 조금 더 빠르지만 애플리케이션을 만드는 관점에서 보면 거의 차이가 없는 수준이다.
    cpu연산을 아주 많이 수행하는 특수한 환경이 아니면 유지보수하기 더 나은 것을 선택하면 된다.

--Class 클래스--
Class클래스는 클래스의 정보를 다루는데 사용된다.
    실행중인 자바 애플리케이션 내에서 필요한 클래스의 속성과 메서드에 대한 정보를 조회하고 조작할 수 있다.
Class클래스의 주요 기능 : 타입 정보 얻기, 리플렉션, 동적 로딩과 생성, 애노테이션 처리 등이 있다.
예를 들어, String.class는 String클래스에 대한 Class객체를 나타내며, 이를 통해 String클래스에 대한 메타데이터를 조회, 조작할 수있다.
Class클래스는 3가지 방법으로 초기화 가능하다.
     Class clazz = String.class; // 1.클래스에서 조회
    Class clazz = new String().getClass();// 2.인스턴스에서 조회
    Class clazz = Class.forName("java.lang.String"); // 3.문자열로 조회

--System 클래스--
시스템과 관련된 기본 기능들을 제공한다.
표준 입력,출력,오류 스트림 System.in / .out / .err
시간 측정 System.currentTimeMillis() / .nanoTime()
환경 변수 .getenv()
시스템 속성 .getProperties()
시스템 종료 .exit()
배열 고속 복사 .arraycopy

--Math, Random 클래스 --
Math 클래스에는 기본 연산(abs, max, min), 지수 및 로그 연산, 반올림 및 정밀도,
    삼각 함수, sqrt나 random같은 유용한 메서드 들이 있다.
Math.random()을 사용해도 되지만, Random클래스를 사용하면 더욱 다양한 랜덤값을 구할 수 있다.
    Random클래스는 java.util 패키지 소속이다.
random.nextInt() 랜덤 int값을 반환한다 / .nextDouble() 0.0d ~ 1.0d 사이의 랜덤 double값을 반환한다.
    .nextBoolean() 랜덤 boolean값을 반환한다. / nextInt(int bound) 0 ~ bound 미만의 숫자를 랜덤으로 반환한다.
 Random random = new Random(1); 이처럼 random 객체를 생성할 때 Seed값을 넣어주면, 시드 값이 같으면 항상 같은 결과가 출력된다.

-- 타입 안전 열거형 패턴 --
회원 등급을 다루는 클래스를 만들고, 각각의 회원 등급별로 상수(static final)를 선언한다.
이때 각각의 상수마다 별도의 인스턴스를 생성하고, 생성한 인스턴스를 대입한다.
 public static final ClassGrade BASIC = new ClassGrade();
 public static final ClassGrade GOLD = new ClassGrade();
 public static final ClassGrade DIAMOND = new ClassGrade();
그리고 메인함수에서
 if (classGrade == ClassGrade.BASIC) {
            discountPercent = 10;
        } 이런 형식으로 같은 객체인지 확인하면 된다.
그런데 이때 외부에서 임의로 인스턴스를 생성할 수 있으므로, 회원 등급을 다루는 클래스의 기본 생성자를 private로 변경해주면 된다.
타입 안전 열거형 패턴의 장점
    1. 타입 안전성 향상, 정해진 객체만 사용할 수 있기 때문에, 잘못된 값을 입력하는 문제를 근본적으로 방지할 수 있다.
    2. 데이터 일관성 : 정해진 객체만 사용하므로 데이터의 일관성이 보장된다.
    +제한된 인스턴스 생성 : 사전에 정의된 몇 개의 인스턴스만 생성하고, 외부에서는 이 인스턴스들만 사용 할 수 있도록 한다.
    +타입 안정성 : 이 패턴을 사용하면 잘못된 값이 할당되거나 사용되는 것을 컴파일 시점에 방지할 수 있다.

자바는 이 타입 안전 열거형 패턴을 편리하게 사용할 수 있는 열거형(Enum Type)을 제공한다.

--열거형(Enum type)--
Enum클래스는 전에 배운 타입 안전 열거형 패턴을 매우 편리하게 사용할 수 있는 열거형(Enum Type)을 제공한다.
public enum Grade {
 BASIC, GOLD, DIAMOND
 }
이와같이 enum으로 클래스를 만들고, 원하는 상수의 이름을 나열하면 된다.
열거형은 자동으로 java.lang.Enum을 상속받는다.
+열거형을 사용하는 경우 static import를 적절하게 사용하면 읽기 좋은 코드를 만들 수 있다.

==열거형의 주요 메서드==
Grade[] values = Grade.values(); // 모든 Enum상수를 포함하는 배열을 반환한다.
valueOf(String name) // 주어진 이름과 일치하는 Enum상수를 반환한다.
.name(), ordinal() // Enum상수의 이름을 문자열로 반환한다,  Enum 상수의 선언 순서를 반환한다.
+ordinal 은 사용을 안하는게 좋다.  중간에 상수의 위치 변경이 가능하기 떄문이다.


===날짜와 시간 일단 PASS, 추후 강의 수강 필요===


--중첩 클래스, 내부 클래스--
중첩 클래스 :
1. 정적 중첩 클래스(정적 변수와 같은 위치에 선언)
2. 내부 클래스 - 내부 클래스(인스턴스 변수와 같은 위치), 지역 클래스(지역 변수와 같은 위치), 익명 클래스
중첩(Nested)과 내부(Inner)를 분류하는 핵심은 바로 바깥 클래스 입장에서 볼 때 안에 있는
    클래스가 나의 인스턴스에 소속이 되는가, 되지 않는가의 차이이다.
    정리하면 내부 클래스들은 바깥 클래스의 인스턴스에 소속된다. 정적 중첩 클래스는 그렇지 않다.
+중첩 클래스는 언제 사용해야 하나?
    특정 클래스가 다른 하나의 클래스 안에서만 사용되거나, 둘이 아주 긴밀하게 연결되어 있는 특별한 경우에만 사용한다.
    외부의 다른 클래스가 특정 중첩 클래스를 사용한다면 중첩 클래스로 만들면 안된다.

-- 정적 중첩 클래스--
정적 중첩 클래스는 사실 다른 클래스를 그냥 중첩해 둔 것이다.
쉽게 이야기해서 둘은 아무런 관계가 없다.
다만, 일반 클래스와 정적 중첩 클래스의 유일한 차이는 private 접근 제어자에 접근 가능 여부이다.
정적 중첩 클래스는 new 바깥클래스.중첩클래스() 로 생성할 수 있다.

-- 내부 클래스 --
내부 클래스는 바깥 인스턴스를 이루는 요소이다. 즉, 내부 클래스는 바깥 클래스의 인스턴스에 소속된다.
내부 클래스는 바깥 클래스의 인스턴스에 소속된다. 따라서 바깥 클래스의 인스턴스 정보를 알아야 생성할 수 있다.
    바깥클래스의 인스턴스 참조.new 내부클래스() 로 생성할 수 있다.






